{"version":3,"sources":["webpack://MiniSearch/webpack/universalModuleDefinition","webpack://MiniSearch/webpack/bootstrap","webpack://MiniSearch/./src/SearchableMap/TreeIterator.js","webpack://MiniSearch/./src/SearchableMap/fuzzySearch.js","webpack://MiniSearch/./src/SearchableMap/SearchableMap.js","webpack://MiniSearch/./src/MiniSearch.js","webpack://MiniSearch/./src/index.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","TreeIterator","set","type","node","_tree","keys","path","length","dive","backtrack","done","last","LEAF","result","push","pop","_prefix","map","filter","join","VALUES","KEYS","iterator","array","withinDistance","a","b","maxDistance","edit","stack","distance","ia","ib","results","NONE","ADD","DELETE","CHANGE","fuzzySearch","query","innerStack","forEach","k","totDistance","Infinity","SearchableMap","tree","prefix","startsWith","Error","trackDown","slice","undefined","parentNode","nodeKey","find","_size","remove","fn","maxEditDistance","lookup","createPath","entries","from","fromObject","toSplit","commonPrefix","Math","min","cleanup","merge","OR","MiniSearch","options","_options","defaultOptions","searchOptions","defaultSearchOptions","fields","_index","_documentCount","_documentIds","_fieldIds","_fieldLength","_averageFieldLength","_nextId","_storedFields","addFields","json","loadJS","JSON","parse","optionName","includes","js","index","documentCount","nextId","documentIds","fieldIds","fieldLength","averageFieldLength","storedFields","miniSearch","document","extractField","tokenize","processTerm","idField","shortDocumentId","addDocumentId","saveStoredFields","field","tokens","addFieldLength","term","processedTerm","isTruthy","addTerm","documents","add","chunkSize","acc","chunk","promise","Promise","resolve","reduce","then","addAll","longId","removeTerm","queryString","searchTokenize","searchProcessTerm","queries","termToQuery","executeQuery","combinedResults","combineResults","combineWith","docId","score","match","terms","id","uniq","assign","sort","defaultAutoSuggestOptions","suggestions","search","phrase","count","suggestion","boosts","boost","boostDocument","weights","fuzzy","fuzzyWeight","prefixWeight","exactMatch","termResults","atPrefix","data","weightedDistance","round","fuzzyGet","combinators","operator","toLowerCase","fieldId","documentId","update","indexData","fieldIndex","df","ds","has","warnDocumentChanged","console","warn","fieldName","toString","editDistance","tf","docBoost","normalizedLength","totalLength","doc","storeFields","fieldValue","combined","termFrequency","documentFrequency","log","element","indexOf","x","string","_fieldName","split","SPACE_OR_PUNCTUATION"],"mappings":"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","file":"minisearch.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"minisearch\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"minisearch\"] = factory();\n\telse\n\t\troot[\"MiniSearch\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n* @private\n*/\nclass TreeIterator {\n  constructor (set, type) {\n    const node = set._tree\n    const keys = Object.keys(node)\n    this.set = set\n    this.type = type\n    this.path = keys.length > 0 ? [{ node, keys }] : []\n  }\n\n  next () {\n    const value = this.dive()\n    this.backtrack()\n    return value\n  }\n\n  dive () {\n    if (this.path.length === 0) { return { done: true } }\n    const { node, keys } = last(this.path)\n    if (last(keys) === LEAF) { return { done: false, value: this.result() } }\n    this.path.push({ node: node[last(keys)], keys: Object.keys(node[last(keys)]) })\n    return this.dive()\n  }\n\n  backtrack () {\n    if (this.path.length === 0) { return }\n    last(this.path).keys.pop()\n    if (last(this.path).keys.length > 0) { return }\n    this.path.pop()\n    this.backtrack()\n  }\n\n  key () {\n    return this.set._prefix + this.path\n      .map(({ keys }) => last(keys))\n      .filter(key => key !== LEAF)\n      .join('')\n  }\n\n  value () {\n    return last(this.path).node[LEAF]\n  }\n\n  result () {\n    if (this.type === VALUES) { return this.value() }\n    if (this.type === KEYS) { return this.key() }\n    return [this.key(), this.value()]\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n}\n\n/** @ignore */\nconst ENTRIES = 'ENTRIES'\n\n/** @ignore */\nconst KEYS = 'KEYS'\n\n/** @ignore */\nconst VALUES = 'VALUES'\n\n/** @ignore */\nconst LEAF = ''\n\nconst last = function (array) {\n  return array[array.length - 1]\n}\n\nexport { TreeIterator, ENTRIES, KEYS, VALUES, LEAF }\n","import { LEAF } from './TreeIterator.js'\n\n/**\n* @ignore\n*/\nexport const fuzzySearch = function (node, query, maxDistance) {\n  const stack = [{ distance: 0, i: 0, key: '', node }]\n  const results = {}\n  const innerStack = []\n\n  while (stack.length > 0) {\n    const { node, distance, key, i, edit } = stack.pop()\n    Object.keys(node).forEach((k) => {\n      if (k === LEAF) {\n        const totDistance = distance + (query.length - i)\n        const [, d] = results[key] || [null, Infinity]\n        if (totDistance <= maxDistance && totDistance < d) {\n          results[key] = [node[k], totDistance]\n        }\n      } else {\n        withinDistance(query, k, maxDistance - distance, i, edit, innerStack).forEach(({ distance: d, i, edit }) => {\n          stack.push({ node: node[k], distance: distance + d, key: key + k, i, edit })\n        })\n      }\n    })\n  }\n  return results\n}\n\n/**\n* @ignore\n*/\nexport const withinDistance = function (a, b, maxDistance, i, edit, stack) {\n  stack.push({ distance: 0, ia: i, ib: 0, edit })\n  const results = []\n\n  while (stack.length > 0) {\n    const { distance, ia, ib, edit } = stack.pop()\n\n    if (ib === b.length) {\n      results.push({ distance, i: ia, edit })\n      continue\n    }\n\n    if (a[ia] === b[ib]) {\n      stack.push({ distance, ia: ia + 1, ib: ib + 1, edit: NONE })\n    } else {\n      if (distance >= maxDistance) { continue }\n\n      if (edit !== ADD) {\n        stack.push({ distance: distance + 1, ia, ib: ib + 1, edit: DELETE })\n      }\n\n      if (ia < a.length) {\n        if (edit !== DELETE) {\n          stack.push({ distance: distance + 1, ia: ia + 1, ib, edit: ADD })\n        }\n\n        if (edit !== DELETE && edit !== ADD) {\n          stack.push({ distance: distance + 1, ia: ia + 1, ib: ib + 1, edit: CHANGE })\n        }\n      }\n    }\n  }\n\n  return results\n}\n\nconst NONE = 0\nconst CHANGE = 1\nconst ADD = 2\nconst DELETE = 3\n\nexport default fuzzySearch\n","import { TreeIterator, ENTRIES, KEYS, VALUES, LEAF } from './TreeIterator.js'\nimport fuzzySearch from './fuzzySearch.js'\n\n/**\n* A class implementing the same interface as a standard JavaScript `Map` with\n* string keys, but adding support for efficiently searching entries with prefix\n* or fuzzy search. This is the class internally used by `MiniSearch` as the\n* inverted index data structure. The implementation is a radix tree (compressed\n* prefix tree).\n*\n* @implements {Map}\n*/\nclass SearchableMap {\n  constructor (tree = {}, prefix = '') {\n    /** @private */\n    this._tree = tree\n    /** @private */\n    this._prefix = prefix\n  }\n\n  /**\n  * Creates and returns a mutable view of this `SearchableMap`, containing only\n  * entries that share the given prefix.\n  *\n  * @example\n  * let map = new SearchableMap()\n  * map.set(\"unicorn\", 1)\n  * map.set(\"universe\", 2)\n  * map.set(\"university\", 3)\n  * map.set(\"unique\", 4)\n  * map.set(\"hello\", 5)\n  *\n  * let uni = map.atPrefix(\"uni\")\n  * uni.get(\"unique\") // => 4\n  * uni.get(\"unicorn\") // => 1\n  * uni.get(\"hello\") // => undefined\n  *\n  * let univer = map.atPrefix(\"univer\")\n  * uni.get(\"unique\") // => undefined\n  * uni.get(\"universe\") // => 2\n  * uni.get(\"university\") // => 3\n  *\n  * @param {string} prefix - The prefix\n  * @return {SearchableMap} A `SearchableMap` representing a mutable view of the original Map at the given prefix\n  */\n  atPrefix (prefix) {\n    if (!prefix.startsWith(this._prefix)) { throw new Error('Mismatched prefix') }\n    const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length))\n    if (node === undefined) {\n      const [parentNode, key] = last(path)\n      const nodeKey = Object.keys(parentNode).find(k => k !== LEAF && k.startsWith(key))\n      if (nodeKey !== undefined) {\n        return new SearchableMap({ [nodeKey.slice(key.length)]: parentNode[nodeKey] }, prefix)\n      }\n    }\n    return new SearchableMap(node || {}, prefix)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\n  * @return {undefined}\n  */\n  clear () {\n    delete this._size\n    this._tree = {}\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\n  * @param {string} key\n  * @return {undefined}\n  */\n  delete (key) {\n    delete this._size\n    return remove(this._tree, key)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\n  * @return {Iterator}\n  */\n  entries () {\n    return new TreeIterator(this, ENTRIES)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\n  * @param {function(key: string, value: any): any} fn\n  * @return {undefined}\n  */\n  forEach (fn) {\n    for (let [key, value] of this) {\n      fn(key, value, this)\n    }\n  }\n\n  /**\n  * Returns a key-value object of all the entries that have a key within the\n  * given edit distance from the search key. The keys of the returned object are\n  * the matching keys, while the values are two-elements arrays where the first\n  * element is the value associated to the key, and the second is the edit\n  * distance of the key to the search key.\n  *\n  * @example\n  * let map = new SearchableMap()\n  * map.set('hello', 'world')\n  * map.set('hell', 'yeah')\n  * map.set('ciao', 'mondo')\n  *\n  * // Get all entries that match the key 'hallo' with a maximum edit distance of 2\n  * map.fuzzyGet('hallo', 2)\n  * // => { \"hello\": [\"world\", 1], \"hell\": [\"yeah\", 2] }\n  *\n  * // In the example, the \"hello\" key has value \"world\" and edit distance of 1\n  * // (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n  * // (change \"e\" to \"a\", delete \"o\")\n  *\n  * @param {string} key - The search key\n  * @param {number} maxEditDistance - The maximum edit distance\n  * @return {Object<string, Array>} A key-value object of the matching keys to their value and edit distance\n  */\n  fuzzyGet (key, maxEditDistance) {\n    return fuzzySearch(this._tree, key, maxEditDistance)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\n  * @param {string} key\n  * @return {any}\n  */\n  get (key) {\n    const node = lookup(this._tree, key)\n    return node !== undefined ? node[LEAF] : undefined\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\n  * @param {string} key\n  * @return {boolean}\n  */\n  has (key) {\n    const node = lookup(this._tree, key)\n    return node !== undefined && node.hasOwnProperty(LEAF)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\n  * @return {Iterator}\n  */\n  keys () {\n    return new TreeIterator(this, KEYS)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\n  * @param {string} key\n  * @param {any} value\n  * @return {SearchableMap} The `SearchableMap` itself, to allow chaining\n  */\n  set (key, value) {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    delete this._size\n    const node = createPath(this._tree, key)\n    node[LEAF] = value\n    return this\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\n  * @type {number}\n  */\n  get size () {\n    if (this._size) { return this._size }\n    /** @ignore */\n    this._size = 0\n    this.forEach(() => { this._size += 1 })\n    return this._size\n  }\n\n  /**\n  * Updates the value at the given key using the provided function. The function\n  * is called with the current value at the key, and its return value is used as\n  * the new value to be set.\n  *\n  * @example\n  * // Increment the current value by one\n  * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)\n  *\n  * @param {string} key - The key\n  * @param {function(currentValue: any): any} fn - The function used to compute the new value from the current one\n  * @return {SearchableMap} The `SearchableMap` itself, to allow chaining\n  */\n  update (key, fn) {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    delete this._size\n    const node = createPath(this._tree, key)\n    node[LEAF] = fn(node[LEAF])\n    return this\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\n  * @return {Iterator}\n  */\n  values () {\n    return new TreeIterator(this, VALUES)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n  * @return {Iterator}\n  */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n}\n\n/**\n* Creates a `SearchableMap` from an `Iterable` of entries\n*\n* @param {Iterable|Array} entries - Entries to be inserted in the `SearchableMap`\n* @return {SearchableMap} A new `SearchableMap` with the given entries\n**/\nSearchableMap.from = function (entries) {\n  const tree = new SearchableMap()\n  for (let [key, value] of entries) {\n    tree.set(key, value)\n  }\n  return tree\n}\n\n/**\n* Creates a `SearchableMap` from the iterable properties of a JavaScript object\n*\n* @param {Object} object - Object of entries for the `SearchableMap`\n* @return {SearchableMap} A new `SearchableMap` with the given entries\n**/\nSearchableMap.fromObject = function (object) {\n  return SearchableMap.from(Object.entries(object))\n}\n\nconst trackDown = function (tree, key, path = []) {\n  if (key.length === 0) { return [tree, path] }\n  const nodeKey = Object.keys(tree).find(k => k !== LEAF && key.startsWith(k))\n  if (nodeKey === undefined) { return trackDown(undefined, '', [...path, [tree, key]]) }\n  return trackDown(tree[nodeKey], key.slice(nodeKey.length), [...path, [tree, nodeKey]])\n}\n\nconst lookup = function (tree, key) {\n  if (key.length === 0) { return tree }\n  const nodeKey = Object.keys(tree).find(k => k !== LEAF && key.startsWith(k))\n  if (nodeKey === undefined) { return undefined }\n  return lookup(tree[nodeKey], key.slice(nodeKey.length))\n}\n\nconst createPath = function (tree, key) {\n  if (key.length === 0) { return tree }\n  const nodeKey = Object.keys(tree).find(k => k !== LEAF && key.startsWith(k))\n  if (nodeKey === undefined) {\n    const toSplit = Object.keys(tree).find(k => k !== LEAF && k.startsWith(key[0]))\n    if (toSplit === undefined) {\n      tree[key] = {}\n    } else {\n      const prefix = commonPrefix(key, toSplit)\n      tree[prefix] = { [toSplit.slice(prefix.length)]: tree[toSplit] }\n      delete tree[toSplit]\n      return createPath(tree[prefix], key.slice(prefix.length))\n    }\n    return tree[key]\n  }\n  return createPath(tree[nodeKey], key.slice(nodeKey.length))\n}\n\nconst commonPrefix = function (a, b, i = 0, length = Math.min(a.length, b.length), prefix = '') {\n  if (i >= length) { return prefix }\n  if (a[i] !== b[i]) { return prefix }\n  return commonPrefix(a, b, i + 1, length, prefix + a[i])\n}\n\nconst remove = function (tree, key) {\n  const [node, path] = trackDown(tree, key)\n  if (node === undefined) { return }\n  delete node[LEAF]\n  const keys = Object.keys(node)\n  if (keys.length === 0) { cleanup(path) }\n  if (keys.length === 1) { merge(path, keys[0], node[keys[0]]) }\n}\n\nconst cleanup = function (path) {\n  if (path.length === 0) { return }\n  const [node, key] = last(path)\n  delete node[key]\n  if (Object.keys(node).length === 0) {\n    cleanup(path.slice(0, -1))\n  }\n}\n\nconst merge = function (path, key, value) {\n  if (path.length === 0) { return }\n  const [node, nodeKey] = last(path)\n  node[nodeKey + key] = value\n  delete node[nodeKey]\n}\n\nconst last = function (array) {\n  return array[array.length - 1]\n}\n\nexport default SearchableMap\nexport { SearchableMap }\n","import SearchableMap from './SearchableMap/SearchableMap.js'\n\nconst OR = 'or'\nconst AND = 'and'\n\n/**\n* MiniSearch is the main entrypoint class, and represents a full-text search\n* engine.\n*\n* @example\n* const documents = [\n*   {\n*     id: 1,\n*     title: 'Moby Dick',\n*     text: 'Call me Ishmael. Some years ago...',\n*     category: 'fiction'\n*   },\n*   {\n*     id: 2,\n*     title: 'Zen and the Art of Motorcycle Maintenance',\n*     text: 'I can see by my watch...',\n*     category: 'fiction'\n*   },\n*   {\n*     id: 3,\n*     title: 'Neuromancer',\n*     text: 'The sky above the port was...',\n*     category: 'fiction'\n*   },\n*   {\n*     id: 4,\n*     title: 'Zen and the Art of Archery',\n*     text: 'At first sight it must seem...',\n*     category: 'non-fiction'\n*   },\n*   // ...and more\n* ]\n*\n* // Create a search engine that indexes the 'title' and 'text' fields for\n* // full-text search. Search results will include 'title' and 'category' (plus the\n* // id field, that is always stored and returned)\n* const miniSearch = MiniSearch.new({\n*   fields: ['title', 'text'],\n*   storeFields: ['title', 'category']\n* })\n*\n* // Add documents to the index\n* miniSearch.addAll(documents)\n*\n* // Search for documents:\n* let results = miniSearch.search('zen art motorcycle')\n* // => [\n*   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },\n*   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }\n* ]\n* */\nclass MiniSearch {\n  /**\n  * @param {Object} options - Configuration options\n  * @param {Array<string>} options.fields - Fields to be indexed. Required.\n  * @param {string} [options.idField='id'] - ID field, uniquely identifying a document\n  * @param {Array<string>} [options.storeFields] - Fields to store, so that search results would include them. By default none, so resuts would only contain the id field.\n  * @param {function(document: Object, fieldName: string): string} [options.extractField] - Function used to get the value of a field in a document\n  * @param {function(text: string, [fieldName]: string): Array<string>} [options.tokenize] - Function used to split a field into individual terms\n  * @param {function(term: string, [fieldName]: string): string} [options.processTerm] - Function used to process a term before indexing it or searching\n  * @param {Object} [options.searchOptions] - Default search options (see the `search` method for details)\n  *\n  * @example\n  * // Create a search engine that indexes the 'title' and 'text' fields of your\n  * // documents:\n  * const miniSearch = MiniSearch.new({ fields: ['title', 'text'] })\n  *\n  * @example\n  * // Your documents are assumed to include a unique 'id' field, but if you want\n  * // to use a different field for document identification, you can set the\n  * // 'idField' option:\n  * const miniSearch = MiniSearch.new({ idField: 'key', fields: ['title', 'text'] })\n  *\n  * @example\n  * // The full set of options (here with their default value) is:\n  * const miniSearch = MiniSearch.new({\n  *   // idField: field that uniquely identifies a document\n  *   idField: 'id',\n  *\n  *   // extractField: function used to get the value of a field in a document.\n  *   // By default, it assumes the document is a flat object with field names as\n  *   // property keys and field values as string property values, but custom logic\n  *   // can be implemented by setting this option to a custom extractor function.\n  *   extractField: (document, fieldName) => document[fieldName],\n  *\n  *   // tokenize: function used to split fields into individual terms. By\n  *   // default, it is also used to tokenize search queries, unless a specific\n  *   // `tokenize` search option is supplied. When tokenizing an indexed field,\n  *   // the field name is passed as the second argument.\n  *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n  *\n  *   // processTerm: function used to process each tokenized term before\n  *   // indexing. It can be used for stemming and normalization. Return a falsy\n  *   // value in order to discard a term. By default, it is also used to process\n  *   // search queries, unless a specific `processTerm` option is supplied as a\n  *   // search option. When processing a term from a indexed field, the field\n  *   // name is passed as the second argument.\n  *   processTerm: (term, _fieldName) => term.toLowerCase(),\n  *\n  *   // searchOptions: default search options, see the `search` method for\n  *   // details\n  *   searchOptions: undefined,\n  *\n  *   // fields: document fields to be indexed. Mandatory, but not set by default\n  *   fields: undefined\n  *\n  *   // storeFields: document fields to be stored and returned as part of the\n  *   // search results.\n  *   storeFields: []\n  * })\n  */\n  constructor (options = {}) {\n    /** @private */\n    this._options = { ...defaultOptions, ...options }\n\n    this._options.searchOptions = { ...defaultSearchOptions, ...(this._options.searchOptions || {}) }\n    const { fields } = this._options\n\n    if (fields == null) {\n      throw new Error('MiniSearch: option \"fields\" must be provided')\n    }\n\n    /** @private */\n    this._index = new SearchableMap()\n\n    /** @private */\n    this._documentCount = 0\n\n    /** @private */\n    this._documentIds = {}\n\n    /** @private */\n    this._fieldIds = {}\n\n    /** @private */\n    this._fieldLength = {}\n\n    /** @private */\n    this._averageFieldLength = {}\n\n    /** @private */\n    this._nextId = 0\n\n    /** @private */\n    this._storedFields = {}\n\n    addFields(this, fields)\n  }\n\n  /**\n  * Adds a document to the index\n  *\n  * @param {Object} document - the document to be indexed\n  */\n  add (document) {\n    const { extractField, tokenize, processTerm, fields, idField } = this._options\n    if (document[idField] == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n    const shortDocumentId = addDocumentId(this, document[idField])\n    saveStoredFields(this, shortDocumentId, document)\n\n    fields.forEach(field => {\n      const tokens = tokenize(extractField(document, field) || '', field)\n      addFieldLength(this, shortDocumentId, this._fieldIds[field], this.documentCount - 1, tokens.length)\n      tokens.forEach(term => {\n        const processedTerm = processTerm(term, field)\n        if (isTruthy(processedTerm)) {\n          addTerm(this, this._fieldIds[field], shortDocumentId, processedTerm)\n        }\n      })\n    })\n  }\n\n  /**\n  * Adds all the given documents to the index\n  *\n  * @param {Object[]} documents - an array of documents to be indexed\n  */\n  addAll (documents) {\n    documents.forEach(document => this.add(document))\n  }\n\n  /**\n  * Adds all the given documents to the index asynchronously.\n  *\n  * Returns a promise that resolves to undefined when the indexing is done. This\n  * method is useful when index many documents, to avoid blocking the main\n  * thread. The indexing is performed asynchronously and in chunks.\n  *\n  * @param {Object[]} documents - an array of documents to be indexed\n  * @param {Object} [options] - Configuration options\n  * @param {number} [options.chunkSize] - Size of the document chunks indexed, 10 by default\n  * @return {Promise} A promise resolving to `null` when the indexing is done\n  */\n  addAllAsync (documents, options = {}) {\n    const { chunkSize = 10 } = options\n    const acc = { chunk: [], promise: Promise.resolve(null) }\n\n    const { chunk, promise } = documents.reduce(({ chunk, promise }, document, i) => {\n      chunk.push(document)\n      if ((i + 1) % chunkSize === 0) {\n        return { chunk: [], promise: promise.then(() => this.addAll(chunk)) }\n      } else {\n        return { chunk, promise }\n      }\n    }, acc)\n\n    return promise.then(() => this.addAll(chunk))\n  }\n\n  /**\n  * Removes the given document from the index.\n  *\n  * The document to delete must NOT have changed between indexing and deletion,\n  * otherwise the index will be corrupted. Therefore, when reindexing a document\n  * after a change, the correct order of operations is:\n  *\n  *   1. remove old version\n  *   2. apply changes\n  *   3. index new version\n  *\n  * @param {Object} document - the document to be indexed\n  */\n  remove (document) {\n    const { tokenize, processTerm, fields, idField } = this._options\n    if (document[idField] == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n    const [shortDocumentId] = Object.entries(this._documentIds)\n      .find(([_, longId]) => document[idField] === longId) || []\n    if (shortDocumentId == null) {\n      throw new Error(`MiniSearch: cannot remove document with ID ${document[idField]}: it is not in the index`)\n    }\n    fields.filter(field => document[field] != null).forEach(field => {\n      tokenize(document[field], field).forEach(term => {\n        const processedTerm = processTerm(term)\n        if (isTruthy(processedTerm)) {\n          removeTerm(this, this._fieldIds[field], shortDocumentId, processTerm(term))\n        }\n      })\n    })\n    delete this._storedFields[shortDocumentId]\n    delete this._documentIds[shortDocumentId]\n    this._documentCount -= 1\n  }\n\n  /**\n  * Search for documents matching the given search query.\n  *\n  * The result is a list of scored document IDs matching the query, sorted by\n  * descending score, and each including data about which terms were matched and\n  * in which fields.\n  *\n  * @param {string} queryString - Query string to search for\n  * @param {Object} [options] - Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.\n  * @param {Array<string>} [options.fields] - Fields to search in. If omitted, all fields are searched\n  * @param {Object<string, number>} [options.boost] - Key-value object of boosting values for fields\n  * @param {boolean|function(term: string, i: number, terms: Array<string>): boolean} [options.prefix=false] - Whether to perform prefix search. Value can be a boolean, or a function computing the boolean from each tokenized and processed query term. If a function is given, it is called with the following arguments: `term: string` - the query term; `i: number` - the term index in the query terms; `terms: Array<string>` - the array of query terms.\n  * @param {number|function(term: string, i: number, terms: Array<string>): boolean|number} [options.fuzzy=false] - If set to a number greater than or equal 1, it performs fuzzy search within a maximum edit distance equal to that value. If set to a number less than 1, it performs fuzzy search with a maximum edit distance equal to the term length times the value, rouded at the nearest integer. If set to a function, it calls the function for each tokenized and processed query term and expects a numeric value indicating the maximum edit distance, or a falsy falue if fuzzy search should not be performed. If a function is given, it is called with the following arguments: `term: string` - the query term; `i: number` - the term index in the query terms; `terms: Array<string>` - the array of query terms.\n  * @param {string} [options.combineWith='OR'] - How to combine term queries (it can be 'OR' or 'AND')\n  * @param {function(query: string): Array<string>} [options.tokenize] - Function used to tokenize the search query. It defaults to the same tokenizer used for indexing.\n  * @param {function(term: string): string|null|undefined|false} [options.processTerm] - Function used to process each search term. Return a falsy value to discard a term. Defaults to the same function used to process terms upon indexing.\n  * @param {function(result: Object): boolean} [options.filter] - Function used to filter search results, for example on the basis of stored fields\n  * @return {Array<{ id: any, score: number, match: Object }>} A sorted array of scored document IDs matching the search\n  *\n  * @example\n  * // Search for \"zen art motorcycle\" with default options: terms have to match\n  * // exactly, and individual terms are joined with OR\n  * miniSearch.search('zen art motorcycle')\n  * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]\n  *\n  * @example\n  * // Search only in the 'title' field\n  * miniSearch.search('zen', { fields: ['title'] })\n  *\n  * @example\n  * // Boost a field\n  * miniSearch.search('zen', { boost: { title: 2 } })\n  *\n  * @example\n  * // Search for \"moto\" with prefix search (it will match documents\n  * // containing terms that start with \"moto\" or \"neuro\")\n  * miniSearch.search('moto neuro', { prefix: true })\n  *\n  * @example\n  * // Search for \"ismael\" with fuzzy search (it will match documents containing\n  * // terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n  * // (rounded to nearest integer)\n  * miniSearch.search('ismael', { fuzzy: 0.2 })\n  *\n  * @example\n  * // Mix of exact match, prefix search, and fuzzy search\n  * miniSearch.search('ismael mob', {\n  *  prefix: true,\n  *  fuzzy: 0.2\n  * })\n  *\n  * @example\n  * // Perform fuzzy and prefix search depending on the search term. Here\n  * // performing prefix and fuzzy search only on terms longer than 3 characters\n  * miniSearch.search('ismael mob', {\n  *  prefix: term => term.length > 3\n  *  fuzzy: term => term.length > 3 ? 0.2 : null\n  * })\n  *\n  * @example\n  * // Combine search terms with AND (to match only documents that contain both\n  * // \"motorcycle\" and \"art\")\n  * miniSearch.search('motorcycle art', { combineWith: 'AND' })\n  *\n  * @example\n  * // Filter only results in the 'fiction' category (assuming that 'category'\n  * // is a stored field)\n  * miniSearch.search('motorcycle art', {\n  *   filter: (result) => result.category === 'fiction'\n  * })\n  */\n  search (queryString, options = {}) {\n    const { tokenize, processTerm, searchOptions } = this._options\n    options = { tokenize, processTerm, ...searchOptions, ...options }\n    const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options\n    const queries = searchTokenize(queryString)\n      .map((term) => searchProcessTerm(term))\n      .filter(isTruthy)\n      .map(termToQuery(options))\n    const results = queries.map(query => this.executeQuery(query, options))\n    const combinedResults = this.combineResults(results, options.combineWith)\n\n    return Object.entries(combinedResults)\n      .reduce((results, [docId, { score, match, terms }]) => {\n        const result = {\n          id: this._documentIds[docId],\n          terms: uniq(terms),\n          score,\n          match\n        }\n        Object.assign(result, this._storedFields[docId])\n        if (options.filter == null || options.filter(result)) {\n          results.push(result)\n        }\n        return results\n      }, [])\n      .sort(({ score: a }, { score: b }) => a < b ? 1 : -1)\n  }\n\n  /**\n  * Provide suggestions for the given search query\n  *\n  * The result is a list of suggested modified search queries, derived from the\n  * given search query, each with a relevance score, sorted by descending score.\n  *\n  * @param {string} queryString - Query string to be expanded into suggestions\n  * @param {Object} [options] - Search options. The supported options and default values are the same as for the `search` method, except that by default prefix search is performed on the last term in the query.\n  * @return {Array<{ suggestion: string, score: number }>} A sorted array of suggestions sorted by relevance score.\n  *\n  * @example\n  * // Get suggestions for 'neuro':\n  * miniSearch.autoSuggest('neuro')\n  * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]\n  *\n  * @example\n  * // Get suggestions for 'zen ar':\n  * miniSearch.autoSuggest('zen ar')\n  * // => [\n  * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n  * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n  * // ]\n  *\n  * @example\n  * // Correct spelling mistakes using fuzzy search:\n  * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n  * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n  *\n  * @example\n  * // Get suggestions for 'zen ar', but only within the 'fiction' category\n  * // (assuming that 'category' is a stored field):\n  * miniSearch.autoSuggest('zen ar', {\n  *   filter: (result) => result.category === 'fiction'\n  * })\n  * // => [\n  * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n  * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n  * // ]\n  */\n  autoSuggest (queryString, options = {}) {\n    options = { ...defaultAutoSuggestOptions, ...options }\n    const suggestions = this.search(queryString, options).reduce((suggestions, { score, terms }) => {\n      const phrase = terms.join(' ')\n      if (suggestions[phrase] == null) {\n        suggestions[phrase] = { score, terms, count: 1 }\n      } else {\n        suggestions[phrase].score += score\n        suggestions[phrase].count += 1\n      }\n      return suggestions\n    }, {})\n    return Object.entries(suggestions)\n      .map(([suggestion, { score, terms, count }]) => ({ suggestion, terms, score: score / count }))\n      .sort(({ score: a }, { score: b }) => a < b ? 1 : -1)\n  }\n\n  /**\n  * Number of documents in the index\n  *\n  * @type {number}\n  */\n  get documentCount () {\n    return this._documentCount\n  }\n\n  /**\n  * Deserializes a JSON index (serialized with `miniSearch.toJSON()`) and\n  * instantiates a MiniSearch instance. It should be given the same options\n  * originally used when serializing the index.\n  *\n  * **Warning:** JSON (de)serialization of the index is currently tightly\n  * coupled to the index implementation. For this reason, the current\n  * implementation is to be considered a _beta_ feature, subject to breaking\n  * changes changes in future releases. If a breaking change is introduced,\n  * though, it will be properly reported in the changelog.\n  *\n  * @param {string} json - JSON-serialized index\n  * @param {Object} options - configuration options, same as the constructor\n  * @return {MiniSearch} an instance of MiniSearch\n  */\n  static loadJSON (json, options) {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return MiniSearch.loadJS(JSON.parse(json), options)\n  }\n\n  /**\n  * Get the default value of an option. It will throw an error if no option with\n  * the given name exists.\n  *\n  * @param {string} optionName - name of the option\n  * @return {*} the default value of the given option\n  *\n  * @example\n  * // Get default tokenizer\n  * MiniSearch.getDefault('tokenize')\n  *\n  * @example\n  * // Get default term processor\n  * MiniSearch.getDefault('processTerm')\n  *\n  * @example\n  * // Unknown options will throw an error\n  * MiniSearch.getDefault('notExisting')\n  * // => throws 'MiniSearch: unknown option \"notExisting\"'\n  */\n  static getDefault (optionName) {\n    const validKeys = Object.keys(defaultOptions)\n    if (validKeys.includes(optionName)) {\n      return defaultOptions[optionName]\n    } else {\n      throw new Error(`MiniSearch: unknown option \"${optionName}\"`)\n    }\n  }\n\n  /**\n  * @private\n  */\n  static loadJS (js, options = {}) {\n    const {\n      index: { _tree, _prefix },\n      documentCount,\n      nextId,\n      documentIds,\n      fieldIds,\n      fieldLength,\n      averageFieldLength,\n      storedFields\n    } = js\n    const miniSearch = new MiniSearch(options)\n    miniSearch._index = new SearchableMap(_tree, _prefix)\n    miniSearch._documentCount = documentCount\n    miniSearch._nextId = nextId\n    miniSearch._documentIds = documentIds\n    miniSearch._fieldIds = fieldIds\n    miniSearch._fieldLength = fieldLength\n    miniSearch._averageFieldLength = averageFieldLength\n    miniSearch._fieldIds = fieldIds\n    miniSearch._storedFields = storedFields || {}\n    return miniSearch\n  }\n\n  /**\n  * @private\n  * @ignore\n  */\n  executeQuery (query, options = {}) {\n    options = { ...this._options.searchOptions, ...options }\n\n    const boosts = (options.fields || this._options.fields).reduce((boosts, field) =>\n      ({ ...boosts, [field]: boosts[field] || 1 }), options.boost || {})\n\n    const {\n      boostDocument,\n      weights: { fuzzy: fuzzyWeight = 0.9, prefix: prefixWeight = 0.75 }\n    } = options\n\n    const exactMatch = termResults(this, query.term, boosts, boostDocument, this._index.get(query.term))\n\n    if (!query.fuzzy && !query.prefix) { return exactMatch }\n\n    const results = [exactMatch]\n\n    if (query.prefix) {\n      var i = 0;\n      this._index.atPrefix(query.term).forEach((term, data) => {\n        if (++i > 50) return\n        const weightedDistance = (0.3 * (term.length - query.term.length)) / term.length\n        results.push(termResults(this, term, boosts, boostDocument, data, prefixWeight, weightedDistance))\n      })\n    }\n\n    if (query.fuzzy) {\n      const maxDistance = query.fuzzy < 1 ? Math.round(query.term.length * query.fuzzy) : query.fuzzy\n      Object.entries(this._index.fuzzyGet(query.term, maxDistance)).forEach(([term, [data, distance]]) => {\n        const weightedDistance = distance / term.length\n        results.push(termResults(this, term, boosts, boostDocument, data, fuzzyWeight, weightedDistance))\n      })\n    }\n\n    return results.reduce(combinators[OR], {})\n  }\n\n  /**\n  * @private\n  * @ignore\n  */\n  combineResults (results, combineWith = OR) {\n    if (results.length === 0) { return {} }\n    const operator = combineWith.toLowerCase()\n    return results.reduce(combinators[operator], null)\n  }\n\n  /**\n  * Allows serialization of the index to JSON, to possibly store it and later\n  * deserialize it with MiniSearch.loadJSON\n  *\n  * **Warning:** JSON (de)serialization of the index is currently tightly\n  * coupled to the index implementation. For this reason, the current\n  * implementation is to be considered a _beta_ feature, subject to breaking\n  * changes changes in future releases. If a breaking change is introduced,\n  * though, it will be reported in the changelog.\n  *\n  * @return {Object} the serializeable representation of the search index\n  */\n  toJSON () {\n    return {\n      index: this._index,\n      documentCount: this._documentCount,\n      nextId: this._nextId,\n      documentIds: this._documentIds,\n      fieldIds: this._fieldIds,\n      fieldLength: this._fieldLength,\n      averageFieldLength: this._averageFieldLength,\n      storedFields: this._storedFields\n    }\n  }\n}\n\nMiniSearch.SearchableMap = SearchableMap\n\nconst addTerm = function (self, fieldId, documentId, term) {\n  self._index.update(term, indexData => {\n    indexData = indexData || {}\n    const fieldIndex = indexData[fieldId] || { df: 0, ds: {} }\n    if (fieldIndex.ds[documentId] == null) { fieldIndex.df += 1 }\n    fieldIndex.ds[documentId] = (fieldIndex.ds[documentId] || 0) + 1\n    return { ...indexData, [fieldId]: fieldIndex }\n  })\n}\n\nconst removeTerm = function (self, fieldId, documentId, term) {\n  if (!self._index.has(term)) {\n    warnDocumentChanged(self, documentId, fieldId, term)\n    return\n  }\n  self._index.update(term, indexData => {\n    const fieldIndex = indexData[fieldId]\n    if (fieldIndex == null || fieldIndex.ds[documentId] == null) {\n      warnDocumentChanged(self, documentId, fieldId, term)\n      return indexData\n    }\n    if (fieldIndex.ds[documentId] <= 1) {\n      if (fieldIndex.df <= 1) {\n        delete indexData[fieldId]\n        return indexData\n      }\n      fieldIndex.df -= 1\n    }\n    if (fieldIndex.ds[documentId] <= 1) {\n      delete fieldIndex.ds[documentId]\n      return indexData\n    }\n    fieldIndex.ds[documentId] -= 1\n    return { ...indexData, [fieldId]: fieldIndex }\n  })\n  if (Object.keys(self._index.get(term)).length === 0) {\n    self._index.delete(term)\n  }\n}\n\nconst warnDocumentChanged = function (self, shortDocumentId, fieldId, term) {\n  if (console == null || console.warn == null) { return }\n  const fieldName = Object.entries(self._fieldIds).find(([name, id]) => id === fieldId)[0]\n  console.warn(`MiniSearch: document with ID ${self._documentIds[shortDocumentId]} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`)\n}\n\nconst addDocumentId = function (self, documentId) {\n  const shortDocumentId = self._nextId.toString(36)\n  self._documentIds[shortDocumentId] = documentId\n  self._documentCount += 1\n  self._nextId += 1\n  return shortDocumentId\n}\n\nconst addFields = function (self, fields) {\n  fields.forEach((field, i) => { self._fieldIds[field] = i })\n}\n\nconst termResults = function (self, term, boosts, boostDocument, indexData, weight = 1, editDistance = 0) {\n  if (indexData == null) { return {} }\n  return Object.entries(boosts).reduce((results, [field, boost]) => {\n    const fieldId = self._fieldIds[field]\n    const { df, ds } = indexData[fieldId] || { ds: {} }\n    Object.entries(ds).forEach(([documentId, tf]) => {\n      const docBoost = boostDocument ? boostDocument(self._documentIds[documentId], term) : 1\n      if (!docBoost) { return }\n      const normalizedLength = self._fieldLength[documentId][fieldId] / self._averageFieldLength[fieldId]\n      results[documentId] = results[documentId] || { score: 0, match: {}, terms: [] }\n      results[documentId].terms.push(term)\n      results[documentId].match[term] = results[documentId].match[term] || []\n      results[documentId].score += docBoost * score(tf, df, self._documentCount, normalizedLength, boost, editDistance)\n      results[documentId].match[term].push(field)\n    })\n    return results\n  }, {})\n}\n\nconst addFieldLength = function (self, documentId, fieldId, count, length) {\n  self._averageFieldLength[fieldId] = self._averageFieldLength[fieldId] || 0\n  const totalLength = (self._averageFieldLength[fieldId] * count) + length\n  self._fieldLength[documentId] = self._fieldLength[documentId] || {}\n  self._fieldLength[documentId][fieldId] = length\n  self._averageFieldLength[fieldId] = totalLength / (count + 1)\n}\n\nconst saveStoredFields = function (self, documentId, doc) {\n  const { storeFields, extractField } = self._options\n  if (storeFields == null || storeFields.length === 0) { return }\n  self._storedFields[documentId] = self._storedFields[documentId] || {}\n\n  storeFields.forEach((fieldName) => {\n    const fieldValue = extractField(doc, fieldName)\n    if (fieldValue === undefined) { return }\n    self._storedFields[documentId][fieldName] = fieldValue\n  })\n}\n\nconst combinators = {\n  [OR]: function (a, b) {\n    return Object.entries(b).reduce((combined, [documentId, { score, match, terms }]) => {\n      if (combined[documentId] == null) {\n        combined[documentId] = { score, match, terms }\n      } else {\n        combined[documentId].score += score\n        combined[documentId].score *= 1.5\n        combined[documentId].terms = [...combined[documentId].terms, ...terms]\n        Object.assign(combined[documentId].match, match)\n      }\n      return combined\n    }, a || {})\n  },\n  [AND]: function (a, b) {\n    if (a == null) { return b }\n    return Object.entries(b).reduce((combined, [documentId, { score, match, terms }]) => {\n      if (a[documentId] === undefined) { return combined }\n      combined[documentId] = combined[documentId] || {}\n      combined[documentId].score = a[documentId].score + score\n      combined[documentId].match = { ...a[documentId].match, ...match }\n      combined[documentId].terms = [...a[documentId].terms, ...terms]\n      return combined\n    }, {})\n  }\n}\n\nconst tfIdf = function (tf, df, n) {\n  return tf * Math.log(n / df)\n}\n\nconst score = function (termFrequency, documentFrequency, documentCount, normalizedLength, boost, editDistance) {\n  const weight = boost / (1 + (0.333 * boost * editDistance))\n  return weight * tfIdf(termFrequency, documentFrequency, documentCount) / normalizedLength\n}\n\nconst termToQuery = (options) => (term, i, terms) => {\n  const fuzzy = (typeof options.fuzzy === 'function')\n    ? options.fuzzy(term, i, terms)\n    : options.fuzzy\n  const prefix = (typeof options.prefix === 'function')\n    ? options.prefix(term, i, terms)\n    : options.prefix\n  return { term, fuzzy, prefix }\n}\n\nconst uniq = function (array) {\n  return array.filter((element, i, array) => array.indexOf(element) === i)\n}\n\nconst isTruthy = (x) => !!x\n\nconst defaultOptions = {\n  idField: 'id',\n  extractField: (document, fieldName) => document[fieldName],\n  tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n  processTerm: (term, _fieldName) => term.toLowerCase(),\n  fields: undefined,\n  searchOptions: undefined,\n  storeFields: []\n}\n\nconst defaultSearchOptions = {\n  combineWith: OR,\n  prefix: false,\n  fuzzy: false,\n  weights: {}\n}\n\nconst defaultAutoSuggestOptions = {\n  prefix: (term, i, terms) => i === terms.length - 1\n}\n\n// This regular expression matches any Unicode space or punctuation character\n// Adapted from https://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7BZ%7D%5Cp%7BP%7D&abb=on&c=on&esc=on\nconst SPACE_OR_PUNCTUATION = /[\\n\\r -#%-*,-/:;?@[-\\]_{}\\u00A0\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u1680\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2000-\\u200A\\u2010-\\u2029\\u202F-\\u2043\\u2045-\\u2051\\u2053-\\u205F\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u3000-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]+/u\n\nexport default MiniSearch\n","import MiniSearch from './MiniSearch.js'\n\nexport default MiniSearch"],"sourceRoot":""}